// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: loan.sql

package database

import (
	"context"
)

const createLoan = `-- name: CreateLoan :one
INSERT INTO loaned_books( created_at, updated_at, name, date, book_id)
VALUES (
	unixepoch(),
	unixepoch(),
	?,
	?,
	?
)
RETURNING id, created_at, updated_at, date, name, book_id
`

type CreateLoanParams struct {
	Name   string
	Date   string
	BookID int64
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (LoanedBook, error) {
	row := q.db.QueryRowContext(ctx, createLoan, arg.Name, arg.Date, arg.BookID)
	var i LoanedBook
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Date,
		&i.Name,
		&i.BookID,
	)
	return i, err
}

const deleteLoan = `-- name: DeleteLoan :exec
DELETE FROM loaned_books WHERE id = ?
`

func (q *Queries) DeleteLoan(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteLoan, id)
	return err
}

const getAllLoans = `-- name: GetAllLoans :many
SELECT id, name, date, book_id FROM loaned_books
`

type GetAllLoansRow struct {
	ID     int64
	Name   string
	Date   string
	BookID int64
}

func (q *Queries) GetAllLoans(ctx context.Context) ([]GetAllLoansRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLoans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllLoansRow
	for rows.Next() {
		var i GetAllLoansRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Date,
			&i.BookID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoanByBookID = `-- name: GetLoanByBookID :one
SELECT id, name, date, book_id FROM loaned_books WHERE book_id = ?
`

type GetLoanByBookIDRow struct {
	ID     int64
	Name   string
	Date   string
	BookID int64
}

func (q *Queries) GetLoanByBookID(ctx context.Context, bookID int64) (GetLoanByBookIDRow, error) {
	row := q.db.QueryRowContext(ctx, getLoanByBookID, bookID)
	var i GetLoanByBookIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Date,
		&i.BookID,
	)
	return i, err
}

const updateLoan = `-- name: UpdateLoan :one
UPDATE loaned_books
SET
	updated_at = unixepoch(),
	name = ?,
	date = ?
WHERE id = ?
RETURNING id, created_at, updated_at, date, name, book_id
`

type UpdateLoanParams struct {
	Name string
	Date string
	ID   int64
}

func (q *Queries) UpdateLoan(ctx context.Context, arg UpdateLoanParams) (LoanedBook, error) {
	row := q.db.QueryRowContext(ctx, updateLoan, arg.Name, arg.Date, arg.ID)
	var i LoanedBook
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Date,
		&i.Name,
		&i.BookID,
	)
	return i, err
}
